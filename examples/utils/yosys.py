"""Yosys synthesis wrapper for Sky130."""

import re
import subprocess
from dataclasses import dataclass, field
from pathlib import Path
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from pdk.sky130.config import SKY130Config


# ANSI color codes
GREEN = '\033[92m'
RED = '\033[91m'
RESET = '\033[0m'


@dataclass
class SynthesisResult:
    """Result of a Yosys synthesis run."""
    success: bool
    netlist_path: Path
    log_path: Path
    report: dict = field(default_factory=dict)

    def __str__(self) -> str:
        if self.success:
            lines = [f"{GREEN}Synthesis successful{RESET}"]
            lines.append(f"Netlist: {self.netlist_path}")
            if self.report:
                for key, val in self.report.items():
                    lines.append(f"  {key}: {val}")
            return '\n'.join(lines)
        else:
            return f"{RED}Synthesis failed{RESET}\nSee log: {self.log_path}"

    def __repr__(self) -> str:
        return f"SynthesisResult(success={self.success}, netlist_path='{self.netlist_path}')"


class YosysSynthesizer:
    """Run RTL synthesis using Yosys targeting Sky130 standard cells.

    Generates a Yosys TCL script, runs it, and parses the results.

    Example:
        from utils.yosys import YosysSynthesizer
        synth = YosysSynthesizer()
        result = synth.synthesize(
            verilog_files=['src/components/digital/rtl/cic_filter.v'],
            top_module='cic_filter',
            output_dir=Path('work/cic_synth'),
        )
        print(result)
    """

    def __init__(self):
        from pdk.sky130.config import config
        self.config = config

    def synthesize(
        self,
        verilog_files: list[str | Path],
        top_module: str,
        output_dir: str | Path,
        liberty: str | Path | None = None,
    ) -> SynthesisResult:
        """Run Yosys synthesis.

        Args:
            verilog_files: List of Verilog source files.
            top_module: Top-level module name.
            output_dir: Directory for synthesis outputs.
            liberty: Liberty file for mapping. Defaults to typical corner.

        Returns:
            SynthesisResult with netlist path and parsed statistics.
        """
        output_dir = Path(output_dir)
        output_dir.mkdir(parents=True, exist_ok=True)

        liberty = Path(liberty) if liberty else self.config.liberty_tt

        netlist_path = output_dir / f'{top_module}_synth.v'
        log_path = output_dir / 'yosys.log'
        script_path = output_dir / 'synth.tcl'

        # Generate TCL script
        script = self._generate_script(
            verilog_files, top_module, liberty, netlist_path
        )
        script_path.write_text(script)

        # Run Yosys (-s for native script mode)
        result = subprocess.run(
            ['yosys', '-s', script_path.name],
            capture_output=True,
            text=True,
            cwd=output_dir,
        )

        # Save log
        with open(log_path, 'w') as f:
            f.write(result.stdout)
            if result.stderr:
                f.write('\n--- STDERR ---\n')
                f.write(result.stderr)

        success = result.returncode == 0 and netlist_path.exists()

        # Parse statistics from log
        report = self._parse_stats(result.stdout) if success else {}

        return SynthesisResult(
            success=success,
            netlist_path=netlist_path,
            log_path=log_path,
            report=report,
        )

    def _generate_script(
        self,
        verilog_files: list[str | Path],
        top_module: str,
        liberty: Path,
        netlist_path: Path,
    ) -> str:
        """Generate Yosys synthesis script."""
        read_cmds = '\n'.join(
            f'read_verilog {Path(f).resolve()}' for f in verilog_files
        )
        return f"""\
# Yosys synthesis script - generated by PADE
# Target: sky130_fd_sc_hd

# Read RTL
{read_cmds}

# Elaborate
hierarchy -check -top {top_module}

# Synthesize
synth -top {top_module}

# Map flip-flops to Liberty cells
dfflibmap -liberty {liberty.resolve()}

# Map combinational logic
abc -liberty {liberty.resolve()}

# Clean up
clean -purge

# Report statistics
stat -liberty {liberty.resolve()}

# Write gate-level netlist
write_verilog -noattr {netlist_path.name}
"""

    @staticmethod
    def _parse_stats(log: str) -> dict:
        """Parse cell count, wire count, and area from Yosys stat output.

        Parses the final (post-mapping) statistics block which uses the format:
            COUNT AREA cells
            COUNT    - wires
        as well as the "Chip area" summary line.
        """
        report = {}

        # Parse "Chip area for module ...": N.NNN
        m = re.search(r'Chip area for module[^:]*:\s+([\d.]+)', log)
        if m:
            report['area_um2'] = float(m.group(1))

        # Find the last statistics block (post-mapping)
        # Format: "  COUNT AREA cells" or "  COUNT    - wires"
        m = re.search(r'(\d+)\s+[\d.E+\-]+\s+cells', log)
        if m:
            report['cells'] = int(m.group(1))

        m = re.search(r'(\d+)\s+-\s+wires\b', log)
        if m:
            report['wires'] = int(m.group(1))

        return report

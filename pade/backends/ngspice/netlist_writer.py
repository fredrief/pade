"""
SPICE netlist writer for NGspice.
"""

from typing import Optional, Union

from pathlib import Path
from pade.backends.base import NetlistWriter
from pade.core.cell import Cell
from pade.statement import Statement, Analysis, Options, Save, Include, IC


# Primitive cell_name values
SPICE_PRIMITIVES = {'R', 'C', 'L', 'V', 'I'}


def _is_netlist_cell(cell: Cell) -> bool:
    """Check if cell is a NetlistCell (from external file)."""
    # Check by attribute rather than import to avoid circular deps
    return hasattr(cell, 'source_path') and cell.source_path is not None


class SpiceNetlistWriter(NetlistWriter):
    """Generates SPICE format netlists for NGspice."""

    def __init__(self, global_nets: str = '0', ascii_output: bool = False):
        self.global_nets = global_nets
        self.ascii_output = ascii_output

    def write_netlist(self, cell: Cell, output_dir: Union[str, Path],
                      statements: Optional[list[Statement]] = None) -> Path:
        """Write netlist to file.
        
        Args:
            cell: Cell to write netlist for
            output_dir: Directory to write to
            statements: Optional list of statements
            
        Returns:
            Path to the written netlist file
        """
        output_dir = Path(output_dir)
        output_dir.mkdir(parents=True, exist_ok=True)
        path = output_dir / f'{cell.cell_name}.spice'
        with open(path, 'w') as f:
            f.write(self.generate_netlist(cell, statements))
        return path

    def generate_subcircuit(self, cell: Cell) -> str:
        """Generate standalone subcircuit definition (for LVS).
        
        This generates only the .subckt definition without any
        testbench, analysis statements, or includes.
        Includes definitions for all subcircuit cells (NetlistCells
        and regular subcells) so that LVS tools can match pins by name.
        
        Args:
            cell: Cell to generate subcircuit for
            
        Returns:
            SPICE netlist string with just the subcircuit definition
        """
        eff_name = self._get_effective_cell_name(cell)
        lines = [
            f'* {eff_name} - Generated by PADE',
            '',
        ]

        # Include NetlistCell definitions (transistors, etc.)
        for nc in self._get_netlist_cell_definitions(cell):
            lines.append(self._format_subckt(nc))
            lines.append('')

        # Include regular subcircuit definitions
        for defn in self._get_subckt_definitions(cell):
            lines.append(self._format_subckt(defn))
            lines.append('')

        lines.append(self._format_subckt(cell))
        lines.append('')
        lines.append('.end')
        return '\n'.join(lines)

    def generate_netlist(self, cell: Cell,
                         statements: Optional[list[Statement]] = None,
                         output_dir: Union[str, Optional[Path]] = None) -> str:
        """Generate complete SPICE netlist string."""
        lines = []

        lines.append(f'* {cell.cell_name} - Generated by PADE')
        lines.append('')

        # Separate statements into includes (at top) and others (after instances)
        include_stmts = []
        other_stmts = []
        if statements:
            for s in statements:
                if isinstance(s, Include):
                    include_stmts.append(s)
                elif s.raw and s.raw.strip().lower().startswith(('.lib', '.include')):
                    # Raw statements that are includes go at the top
                    include_stmts.append(s)
                else:
                    other_stmts.append(s)

        # Write includes at the top
        for stmt in include_stmts:
            if isinstance(stmt, Include):
                lines.append(self._format_include(stmt))
            else:
                lines.append(stmt.raw)
        if include_stmts:
            lines.append('')

        # Inline external subcircuit definitions (from NetlistCell source files)
        external_paths = self._get_external_subckt_paths(cell)
        if external_paths:
            lines.append('* External subcircuit definitions')
            for path in external_paths:
                lines.append(self._inline_subckt_file(path))
            lines.append('')

        for subckt in self._get_subckt_definitions(cell):
            lines.append(self._format_subckt(subckt))
            lines.append('')

        lines.append('* Top-level instances')
        for subcell in cell.get_subcells():
            lines.append(self._format_instance(subcell))
        lines.append('')

        # Write other statements after instances
        for stmt in other_stmts:
            formatted = self._format_statement(stmt)
            if formatted:
                lines.append(formatted)

        # Add ASCII output if requested
        if self.ascii_output:
            # Get signal names from Save statements
            save_signals = []
            if statements:
                for stmt in statements:
                    if isinstance(stmt, Save):
                        save_signals = stmt.signals
                        break

            if save_signals:
                signal_str = ' '.join(save_signals)
                lines.append(f'.wrdata output.txt {signal_str}')

        lines.append('.end')

        return '\n'.join(lines)

    def _format_statement(self, stmt: Statement) -> str:
        """Format any statement type to SPICE syntax."""
        if stmt.raw is not None:
            return stmt.raw

        if isinstance(stmt, Analysis):
            return self._format_analysis(stmt)
        if isinstance(stmt, Options):
            return self._format_options(stmt)
        if isinstance(stmt, Save):
            return self._format_save(stmt)
        if isinstance(stmt, IC):
            return self._format_ic(stmt)
        if isinstance(stmt, Include):
            return self._format_include(stmt)

        raise ValueError(f"Unknown statement type: {type(stmt)}")

    def _format_analysis(self, analysis: Analysis) -> str:
        """Format analysis statement to SPICE syntax."""
        atype = analysis.analysis_type.lower()

        if atype == 'tran':
            stop = analysis.params.get('stop', '1m')
            step = analysis.params.get('step', self._auto_step(stop))
            start = analysis.params.get('start', '')
            uic = ' uic' if analysis.params.get('uic') else ''
            if start:
                return f'.tran {self._format_value(step)} {self._format_value(stop)} {self._format_value(start)}{uic}'
            return f'.tran {self._format_value(step)} {self._format_value(stop)}{uic}'

        elif atype == 'ac':
            variation = analysis.params.get('variation', 'dec')
            points = analysis.params.get('points', 10)
            start = analysis.params.get('start', 1)
            stop = analysis.params.get('stop', 1e9)
            return f'.ac {variation} {points} {self._format_value(start)} {self._format_value(stop)}'

        elif atype == 'dc':
            src = analysis.params.get('src', 'V1')
            start = analysis.params.get('start', 0)
            stop = analysis.params.get('stop', 1)
            step = analysis.params.get('step', 0.01)
            return f'.dc {src} {self._format_value(start)} {self._format_value(stop)} {self._format_value(step)}'

        elif atype == 'op':
            return '.op'

        elif atype == 'noise':
            output = analysis.params.get('output', 'out')
            src = analysis.params.get('src', 'V1')
            variation = analysis.params.get('variation', 'dec')
            points = analysis.params.get('points', 10)
            start = analysis.params.get('start', 1)
            stop = analysis.params.get('stop', 1e9)
            return f'.noise v({output}) {src} {variation} {points} {self._format_value(start)} {self._format_value(stop)}'

        else:
            params = ' '.join(f'{k}={self._format_value(v)}' for k, v in analysis.params.items())
            return f'.{atype} {params}'

    def _auto_step(self, stop) -> float:
        """Auto-calculate reasonable step size."""
        if isinstance(stop, str):
            stop = self._parse_value(stop)
        return stop / 1000

    def _parse_value(self, s: str) -> float:
        """Parse engineering notation string to float."""
        suffixes = {
            'f': 1e-15, 'p': 1e-12, 'n': 1e-9, 'u': 1e-6, 'm': 1e-3,
            'k': 1e3, 'K': 1e3, 'meg': 1e6, 'M': 1e6, 'g': 1e9, 'G': 1e9, 't': 1e12, 'T': 1e12
        }
        s = s.strip().lower()
        for suffix, mult in suffixes.items():
            if s.endswith(suffix.lower()):
                return float(s[:-len(suffix)]) * mult
        return float(s)

    def _format_options(self, options: Options) -> str:
        """Format options statement."""
        params = ' '.join(f'{k}={self._format_value(v)}' for k, v in options.params.items())
        return f'.options {params}'

    def _format_save(self, save: Save) -> str:
        """Format save statement to SPICE syntax."""
        signals = []
        for sig in save.signals:
            if sig.startswith('i(') or sig.startswith('v('):
                signals.append(sig)
            else:
                signals.append(f'v({sig})')
        return '.save ' + ' '.join(signals)

    def _format_include(self, include: Include) -> str:
        """Format include statement."""
        if include.selector:
            return f'.include "{include.path}" {include.selector}'
        return f'.include "{include.path}"'

    def _format_ic(self, ic: IC) -> str:
        """Format initial conditions."""
        conditions = ' '.join(f'v({node})={self._format_value(value)}'
                             for node, value in ic.conditions.items())
        return f'.ic {conditions}'

    def _is_primitive(self, cell: Cell) -> bool:
        """Check if cell is a primitive component."""
        return cell.cell_name in SPICE_PRIMITIVES

    def _get_effective_cell_name(self, cell: Cell) -> str:
        """Get cell name, using layout's encoded name when layout is attached."""
        if not self._is_primitive(cell) and cell.layout_cell is not None:
            return cell.layout_cell.cell_name
        return cell.cell_name

    def _get_subckt_definitions(self, cell: Cell) -> list[Cell]:
        """Get list of cells that need subckt definitions (excludes NetlistCells)."""
        definitions = []
        seen = set()

        def collect(c: Cell):
            for subcell in c.get_subcells():
                if self._is_primitive(subcell) or _is_netlist_cell(subcell):
                    continue
                eff_name = self._get_effective_cell_name(subcell)
                if subcell.subcells and eff_name not in seen:
                    seen.add(eff_name)
                    collect(subcell)
                    definitions.append(subcell)

        collect(cell)
        return definitions

    def _get_netlist_cell_definitions(self, cell: Cell) -> list[Cell]:
        """Collect unique NetlistCell instances that need subcircuit definitions."""
        definitions = []
        seen = set()

        def collect(c: Cell):
            for subcell in c.get_subcells():
                if _is_netlist_cell(subcell):
                    eff_name = self._get_effective_cell_name(subcell)
                    if eff_name not in seen:
                        seen.add(eff_name)
                        definitions.append(subcell)
                elif not self._is_primitive(subcell):
                    collect(subcell)

        collect(cell)
        return definitions

    def _get_external_subckt_paths(self, cell: Cell) -> set[str]:
        """Collect unique source paths from all external NetlistCell instances."""
        paths: set[str] = set()

        def collect(c: Cell) -> None:
            for subcell in c.get_subcells():
                if _is_netlist_cell(subcell):
                    paths.add(str(subcell.source_path))
                else:
                    collect(subcell)

        collect(cell)
        return paths

    def _inline_subckt_file(self, path: str) -> str:
        """Read and return subcircuit file content for inlining."""
        content = Path(path).read_text()
        # Strip comments at the start but keep the subcircuit definition
        lines = []
        for line in content.split('\n'):
            lines.append(line)
        return '\n'.join(lines).strip()

    def _format_subckt(self, cell: Cell) -> str:
        """Format subcircuit definition.
        
        For NetlistCells: inlines source file with cell name and parameter substitution.
        For regular Cells: generates from Cell structure.
        """
        if _is_netlist_cell(cell):
            return self._format_netlist_cell_subckt(cell)
        
        lines = []
        eff_name = self._get_effective_cell_name(cell)

        terminals = ' '.join(t.name for t in cell.get_all_terminals())
        lines.append(f'.subckt {eff_name} {terminals}')

        for subcell in cell.get_subcells():
            lines.append(self._format_instance(subcell))

        lines.append(f'.ends {eff_name}')
        return '\n'.join(lines)

    def _format_netlist_cell_subckt(self, cell: Cell) -> str:
        """Format NetlistCell by inlining source with substitutions.
        
        - Renames cell to effective_cell_name (includes layout params if attached)
        - Removes .param lines (parameters baked into cell name)
        - Substitutes {param} references with actual values
        """
        import re
        
        orig_name = cell.cell_name
        eff_name = self._get_effective_cell_name(cell)
        content = Path(cell.source_path).read_text()
        
        # Build parameter substitution map
        param_values = {name: p.value for name, p in cell.parameters.items()}
        
        result_lines = []
        for line in content.split('\n'):
            stripped = line.strip().lower()
            
            # Skip .param lines (parameters now baked into name)
            if stripped.startswith('.param'):
                continue
            
            # Replace cell name in .subckt and .ends
            if stripped.startswith('.subckt') or stripped.startswith('.ends'):
                line = re.sub(
                    rf'\b{re.escape(orig_name)}\b',
                    eff_name,
                    line,
                    flags=re.IGNORECASE
                )
            
            # Substitute {param} references with actual values
            for param_name, value in param_values.items():
                line = re.sub(
                    rf'\{{{param_name}\}}',
                    str(value),
                    line,
                    flags=re.IGNORECASE
                )
            
            result_lines.append(line)
        
        return '\n'.join(result_lines).strip()

    def _format_instance(self, cell: Cell) -> str:
        """Format instance line in SPICE syntax."""
        unconnected = [t.name for t in cell.get_all_terminals() if t.net is None]
        if unconnected:
            raise RuntimeError(
                f'Cell {cell.get_name_from_top()} has unconnected terminals: {unconnected}'
            )

        nets = ' '.join(t.net.name for t in cell.get_all_terminals())
        cell_name = cell.cell_name
        eff_name = self._get_effective_cell_name(cell)

        # Get instance name with proper prefix for primitives
        inst_name = cell.instance_name
        if self._is_primitive(cell):
            if not inst_name[0].upper() == cell_name:
                inst_name = cell_name + inst_name

        # Handle primitives
        if cell_name == 'R':
            r = cell.parameters.get('r')
            return f'{inst_name} {nets} {self._format_value(r.value)}'

        elif cell_name == 'C':
            c = cell.parameters.get('c')
            return f'{inst_name} {nets} {self._format_value(c.value)}'

        elif cell_name == 'L':
            l = cell.parameters.get('l')
            return f'{inst_name} {nets} {self._format_value(l.value)}'

        elif cell_name == 'V':
            return self._format_voltage_source(inst_name, nets, cell)

        elif cell_name == 'I':
            return self._format_current_source(inst_name, nets, cell)

        else:
            # Generic subcircuit instance
            if not inst_name.startswith('X'):
                inst_name = 'X' + inst_name
            params = ' '.join(f'{name}={self._format_value(p.value)}'
                             for name, p in cell.parameters.items())
            if params:
                return f'{inst_name} {nets} {eff_name} {params}'
            return f'{inst_name} {nets} {eff_name}'

    def _format_voltage_source(self, inst_name: str, nets: str, cell: Cell) -> str:
        """Format voltage source."""
        params = cell.parameters

        src_func = params.get('type')
        if src_func:
            func_type = src_func.value.lower()
            if func_type == 'sine':
                dc = params.get('sinedc', params.get('dc'))
                dc_val = self._format_value(dc.value) if dc else '0'
                ampl = params.get('ampl')
                ampl_val = self._format_value(ampl.value) if ampl else '1'
                freq = params.get('freq')
                freq_val = self._format_value(freq.value) if freq else '1k'
                return f'{inst_name} {nets} sin({dc_val} {ampl_val} {freq_val})'
            elif func_type == 'pulse':
                v1 = self._format_value(params.get('v1', params.get('low')).value) if params.get('v1') or params.get('low') else '0'
                v2 = self._format_value(params.get('v2', params.get('high')).value) if params.get('v2') or params.get('high') else '1'
                td = self._format_value(params.get('td', params.get('delay')).value) if params.get('td') or params.get('delay') else '0'
                tr = self._format_value(params.get('tr', params.get('rise')).value) if params.get('tr') or params.get('rise') else '1n'
                tf = self._format_value(params.get('tf', params.get('fall')).value) if params.get('tf') or params.get('fall') else '1n'
                pw = self._format_value(params.get('pw', params.get('width')).value) if params.get('pw') or params.get('width') else '1u'
                per = self._format_value(params.get('per', params.get('period')).value) if params.get('per') or params.get('period') else '2u'
                return f'{inst_name} {nets} pulse({v1} {v2} {td} {tr} {tf} {pw} {per})'

        dc = params.get('dc')
        ac = params.get('ac')

        if dc and ac:
            return f'{inst_name} {nets} dc {self._format_value(dc.value)} ac {self._format_value(ac.value)}'
        elif dc:
            return f'{inst_name} {nets} dc {self._format_value(dc.value)}'
        elif ac:
            return f'{inst_name} {nets} ac {self._format_value(ac.value)}'
        else:
            return f'{inst_name} {nets} dc 0'

    def _format_current_source(self, inst_name: str, nets: str, cell: Cell) -> str:
        """Format current source."""
        params = cell.parameters
        dc = params.get('dc')
        ac = params.get('ac')

        if dc and ac:
            return f'{inst_name} {nets} dc {self._format_value(dc.value)} ac {self._format_value(ac.value)}'
        elif dc:
            return f'{inst_name} {nets} dc {self._format_value(dc.value)}'
        elif ac:
            return f'{inst_name} {nets} ac {self._format_value(ac.value)}'
        else:
            return f'{inst_name} {nets} dc 0'

    def _format_value(self, value) -> str:
        """Format parameter value for SPICE netlist."""
        if isinstance(value, str):
            return value
        if isinstance(value, bool):
            return '1' if value else '0'
        if isinstance(value, float):
            if value == 0:
                return '0'
            exp = 0
            v = abs(value)
            if v >= 1:
                while v >= 1000:
                    v /= 1000
                    exp += 3
            else:
                while v < 1:
                    v *= 1000
                    exp -= 3

            prefix = {
                -15: 'f', -12: 'p', -9: 'n', -6: 'u', -3: 'm',
                0: '', 3: 'k', 6: 'meg', 9: 'g', 12: 't'
            }.get(exp, f'e{exp}')

            sign = '-' if value < 0 else ''
            formatted = f'{v:.6g}'
            return f'{sign}{formatted}{prefix}'
        return str(value)

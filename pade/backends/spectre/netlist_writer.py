"""
Spectre netlist writer.
"""

from pathlib import Path
from pade.backends.base import NetlistWriter
from pade.core import Cell
from pade.statement import Statement, Analysis, Options, Save, Include, IC


# Primitive cell_name -> spectre cell name
SPECTRE_PRIMITIVES = {
    'R': 'resistor',
    'C': 'capacitor',
    'L': 'inductor',
    'V': 'vsource',
    'I': 'isource',
}


def _is_netlist_cell(cell: Cell) -> bool:
    """Check if cell is a NetlistCell (imported from external netlist)."""
    # Avoid circular import by checking for source_path attribute
    return hasattr(cell, 'source_path') and cell.source_path is not None


class SpectreNetlistWriter(NetlistWriter):
    """Generates Spectre format netlists."""

    def __init__(self, global_nets: str = '0'):
        self.global_nets = global_nets

    def write_netlist(self, cell: Cell, path: str | Path,
                      statements: list[Statement] | None = None) -> None:
        """Write netlist to file."""
        path = Path(path)
        path.parent.mkdir(parents=True, exist_ok=True)
        with open(path, 'w') as f:
            f.write(self.generate_netlist(cell, statements))

    def generate_netlist(self, cell: Cell,
                         statements: list[Statement] | None = None) -> str:
        """Generate complete netlist string."""
        lines = []
        lines.append('// Generated by PADE')
        lines.append(f'// Top cell: {cell.cell_name}')
        lines.append('simulator lang=spectre')
        lines.append(f'global {self.global_nets}')
        lines.append('')

        # Collect includes from statements
        explicit_includes: list[Include] = []
        if statements:
            explicit_includes = [s for s in statements if isinstance(s, Include)]

        # Write explicit includes
        for inc in explicit_includes:
            lines.append(self._format_include(inc))
        if explicit_includes:
            lines.append('')

        # Inline external subcircuit definitions (from SubcktCell source files)
        external_paths = self._get_external_subckt_paths(cell)
        if external_paths:
            lines.append('// External subcircuit definitions')
            for path in external_paths:
                lines.append(self._inline_subckt_file(path))
            lines.append('')

        # Subcircuit definitions (custom cells only, not external SubcktCells)
        for subckt in self._get_subckt_definitions(cell):
            lines.append(self._format_subckt(subckt))
            lines.append('')

        # Top-level instances
        lines.append(f'// Top-level instances')
        for subcell in cell.get_subcells():
            lines.append(self._format_instance(subcell))
        lines.append('')

        # Other statements (analyses, options, save, etc.)
        if statements:
            non_includes = [s for s in statements if not isinstance(s, Include)]
            for stmt in non_includes:
                lines.append(self._format_statement(stmt))

        return '\n'.join(lines)

    def _get_external_subckt_paths(self, cell: Cell) -> set[str]:
        """Collect unique source paths from all external SubcktCell instances."""
        paths: set[str] = set()

        def collect(c: Cell) -> None:
            for subcell in c.get_subcells():
                if _is_netlist_cell(subcell):
                    if subcell.source_path:
                        paths.add(str(subcell.source_path))
                else:
                    collect(subcell)

        collect(cell)
        return paths

    def _inline_subckt_file(self, path: str) -> str:
        """Read and return subcircuit file content for inlining."""
        from pathlib import Path
        content = Path(path).read_text()
        # Strip any existing simulator lang declarations (we already have one)
        lines = []
        for line in content.split('\n'):
            stripped = line.strip().lower()
            if stripped.startswith('simulator'):
                continue  # Skip simulator directives
            lines.append(line)
        return '\n'.join(lines).strip()

    def _format_statement(self, stmt: Statement) -> str:
        """Format any statement type."""
        if stmt.raw is not None:
            return stmt.raw

        if isinstance(stmt, Analysis):
            return self._format_analysis(stmt)
        if isinstance(stmt, Options):
            return self._format_options(stmt)
        if isinstance(stmt, Save):
            return self._format_save(stmt)
        if isinstance(stmt, IC):
            return self._format_ic(stmt)
        if isinstance(stmt, Include):
            return self._format_include(stmt)

        raise ValueError(f"Unknown statement type: {type(stmt)}")

    def _format_analysis(self, analysis: Analysis) -> str:
        """Format analysis statement."""
        parts = [analysis.name, analysis.analysis_type]
        for key, value in analysis.params.items():
            parts.append(f'{key}={self._format_value(value)}')
        return ' '.join(parts)

    def _format_options(self, options: Options) -> str:
        """Format options statement."""
        parts = [options.name, 'options']
        for key, value in options.params.items():
            parts.append(f'{key}={self._format_value(value)}')
        return ' '.join(parts)

    def _format_save(self, save: Save) -> str:
        """Format save statement."""
        parts = ['save']
        parts.extend(save.signals)
        for key, value in save.settings.items():
            parts.append(f'{key}={self._format_value(value)}')
        return ' '.join(parts)

    def _format_include(self, include: Include) -> str:
        """Format include statement."""
        if include.selector:
            return f'include "{include.path}" {include.selector}'
        return f'include "{include.path}"'

    def _format_ic(self, ic: IC) -> str:
        """Format initial conditions."""
        parts = ['ic']
        for node, value in ic.conditions.items():
            parts.append(f'{node}={self._format_value(value)}')
        return ' '.join(parts)

    def _is_primitive(self, cell: Cell) -> bool:
        """Check if cell is a primitive component."""
        return cell.cell_name in SPECTRE_PRIMITIVES

    def _get_subckt_definitions(self, cell: Cell) -> list[Cell]:
        """
        Get list of cells that need subckt definitions.
        Primitives and external SubcktCells don't need definitions.
        """
        definitions = []
        seen = set()

        def collect(c: Cell) -> None:
            for subcell in c.get_subcells():
                # Skip primitives and external subcircuits
                if self._is_primitive(subcell) or _is_netlist_cell(subcell):
                    continue
                if subcell.subcells and subcell.cell_name not in seen:
                    seen.add(subcell.cell_name)
                    collect(subcell)
                    definitions.append(subcell)

        collect(cell)
        return definitions

    def _format_subckt(self, cell: Cell) -> str:
        """Format subcircuit definition."""
        lines = []

        terminals = ' '.join(t.name for t in cell.get_all_terminals(sort=True))
        lines.append(f'subckt {cell.cell_name} {terminals}')

        if cell.parameters:
            params = ' '.join(
                f'{name}={p.default if p.default is not None else p.value}'
                for name, p in cell.parameters.items()
            )
            lines.append(f'parameters {params}')

        for subcell in cell.get_subcells():
            lines.append(self._format_instance(subcell))

        lines.append(f'ends {cell.cell_name}')
        return '\n'.join(lines)

    def _format_instance(self, cell: Cell) -> str:
        """Format instance line."""
        unconnected = [t.name for t in cell.get_all_terminals() if t.net is None]
        if unconnected:
            raise RuntimeError(
                f'Cell {cell.get_name_from_top()} has unconnected terminals: {unconnected}'
            )

        parts = [cell.instance_name]

        for t in cell.get_all_terminals(sort=True):
            parts.append(t.net.name)

        # Map primitives to Spectre names, otherwise use cell_name
        if self._is_primitive(cell):
            parts.append(SPECTRE_PRIMITIVES[cell.cell_name])
        else:
            parts.append(cell.cell_name)

        for name, param in cell.parameters.items():
            parts.append(f'{name}={self._format_value(param.value)}')

        return ' '.join(parts)

    def _format_value(self, value) -> str:
        """Format parameter value for netlist."""
        if isinstance(value, str):
            return value
        if isinstance(value, bool):
            return 'yes' if value else 'no'
        if isinstance(value, float):
            if value == 0:
                return '0'
            exp = 0
            v = abs(value)
            if v >= 1:
                while v >= 1000:
                    v /= 1000
                    exp += 3
            else:
                while v < 1:
                    v *= 1000
                    exp -= 3

            prefix = {
                -15: 'f', -12: 'p', -9: 'n', -6: 'u', -3: 'm',
                0: '', 3: 'K', 6: 'M', 9: 'G', 12: 'T'
            }.get(exp, f'e{exp}')

            sign = '-' if value < 0 else ''
            formatted = f'{v:.6g}'
            return f'{sign}{formatted}{prefix}'
        return str(value)
